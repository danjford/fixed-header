{"version":3,"file":"fixed-header.js","sources":["../src/events.js","../src/config.js","../src/utils.js","../src/main.js"],"sourcesContent":["import { eventConfig } from './config';\n\n// Getting the scroll top of the passed string element i.e. wouldn't work if you had multiple header elements in the page.\nconst getScrollTop = (el) => {\n  return document.querySelector(el).scrollTop || document.documentElement.scrollTop;\n}\n\n/**\n * Checks if the configured minWidth or the maxWidth has been exceeded and\n * calls the relevant events\n * @param  {Object} _this, the configured instace of FixedHeader\n * @param  {Object} event, the scroll event object\n * @return {Boolean}, whether or not a bound has been exceeded\n */\nconst boundsExceeded = ( _this, event ) => {\n\n  const windowWidth = window.innerWidth,\n    minExceeded = _this.config.minWidth !== null && windowWidth < _this.config.minWidth,\n    maxExceeded = _this.config.maxWidth !== null && windowWidth > _this.config.maxWidth;\n\n  if ( maxExceeded && typeof _this.instance.maxWidthEvent === 'function' ) _this.instance.maxWidthEvent.call( _this, event );\n  if ( minExceeded && typeof _this.instance.minWidthEvent === 'function' ) _this.instance.minWidthEvent.call( _this, event );\n\n  return minExceeded || maxExceeded;\n\n}\n\n\n/**\n * The event which is called on scroll which switched the header between it's normal styling\n * and the fixed styling.\n * @param  {Object} e, the event object\n * @return {Void}, nothing is returned\n */\nfunction scrollEvent(e) {\n\n  const header = this.instance.element;\n\n  // If the bounds are exceeded, cancel!\n  if ( boundsExceeded( this, e ) ) return;\n\n  let isAbsolute = this.instance.isAbsolute,\n    previousScroll = this.instance.previousScroll;\n\n  // The new scrolling position\n  const newScroll = getScrollTop('body'),\n        headerClientHeight = header.clientHeight,\n        headerOffsetTop = header.offsetTop,\n        fixedClass = this.config.fixedClass !== null ? this.config.fixedClass : 'fixed';\n\n  if ( newScroll < previousScroll && (headerClientHeight + headerOffsetTop) < newScroll && isAbsolute ) {\n\n    // If we are scrolling up, place it above the viewport so that it can slide and reveal\n    header.style.top = `${newScroll - headerClientHeight}px`;\n\n  } else if ( newScroll <= headerOffsetTop && isAbsolute ) {\n\n    // We have reached the top of the header, so fix it!\n    header.style.top = 0;\n    header.classList.add( fixedClass );\n    this.instance.isAbsolute = false;\n\n  } else if ( newScroll > previousScroll  && !isAbsolute ) {\n\n    // We are scrolling down again so add the top position to be the current scroll\n    // and remove fixed. This gives the appearance that we are just leaving it there\n    // as it slides out of view.\n    header.style.top = `${newScroll}px`;\n    header.classList.remove( fixedClass );\n    this.instance.isAbsolute = true;\n\n  }\n\n  // Set the scroll for comparison on the next scroll event\n  this.instance.previousScroll = newScroll;\n\n};\n\n/**\n * Sets up the called instance with default configs and sets up the scroll and touch events\n * @return {Void}, nothing is returned\n */\nexport function setupScrollEvent() {\n\n  const conf = this.config;\n\n  this.instance = {\n    isAbsolute: true,\n    previousScroll: getScrollTop('body'),\n    element: typeof conf.element === 'string' ? document.querySelector( conf.element ) : conf.element\n  };\n\n  document.addEventListener( 'scroll', scrollEvent.bind(this) );\n  document.addEventListener( 'touchmove', scrollEvent.bind(this) );\n\n}\n\n/**\n * Sets up the events on the object such as onMaxWidth or onMinWidth\n * @return {Void}, nothing is returned\n */\nexport function setupEvents() {\n\n  for ( var key in eventConfig ) {\n\n    this[ key ] = eventConfig[key];\n\n  }\n\n}\n\n/**\n * Used by the user to set up their maxWidthEvent\n * @param  {Function} callback, the function they want called.\n * @return {Void}, nothing is returned\n */\nexport function onMaxWidth( callback ) {\n  if ( typeof callback === 'function' ) this.instance.maxWidthEvent = callback;\n}\n\n/**\n * Used by the user to set up their minWidthEvent\n * @param  {Function} callback, the function they want called.\n * @return {Void}, nothing is returned\n */\nexport function onMinWidth( callback ) {\n  if ( typeof callback === 'function' ) this.instance.minWidthEvent = callback;\n}","import { onMaxWidth, onMinWidth } from './events';\n\nexport const defaultConfig = {\n\n  type: '',\n  element: '', // The Class or ID to attach the event to\n  offsetTop: 0,\n  minWidth: null, // The minimum width the header should activate on\n  maxWidth: null, // The maximum width the current instance should activate on\n  useStyles: true, // Default - By default inserts styles\n  fixedClass: null, // Add the a CSS class when conditions are met\n  stickToElement: null, // Stick to the specified element\n  dynamicPadding: false // Dynamic padding\n}\n\nexport const eventConfig = {\n  onMinWidth, // The event to happen when the minimum width is reached\n  onMaxWidth // the event to happen when the maximum width is reached\n}","/*\n * The full function for extending an array of objects into a new object,\n * can be optionally deep which will recursively go through properties.\n *\n * @param {Object} dest, the new object to write to\n * @param {Array} objs, the array of objects to extend\n * @param {Boolean} deep, decides if copy should be recursive\n * @return {Object} the new written object\n*/\nexport const fullExtend = ( dest, objs, deep ) => {\n  for (let i = 0, ii = objs.length; i < ii; i++) {\n    let obj = objs[i];\n\n    if (!isObject(obj)) return;\n\n    let objKeys = Object.keys(obj);\n\n    for (let j = 0, jj = objKeys.length; j < jj; j++) {\n      let key = objKeys[j];\n      let val = obj[key];\n\n      if (isObject(val) && deep) {\n        if (!isObject(dest[key])) dest[key] = Array.isArray(val) ? [] : {};\n        fullExtend(dest[key], [val], true);\n      } else {\n        dest[key] = val;\n      }\n    }\n  }\n\n  return dest;\n}\n\n/**\n * Low extend of the object i.e. not recursive copy\n *\n * @param  {Object} dest, the object that will have properties copied to it\n * @param  {Object} val, the second object with the properties to copy or an array of elements\n * @return {Object} the new object with properties copied to it\n */\nexport const lowExtend = ( dest, val ) => {\n  return fullExtend(dest, Array.isArray(val) ? val : [val], false);\n}\n\n/**\n * Deep extend the object i.e. recursive copy\n *\n * @param  {Object} dest, the object that will have properties copied to it\n * @param  {Object|Array} val, the second object with the properties to copy or an array of elements\n * @return {Object} the new object with properties copied to it\n */\nexport const deepExtend = ( dest, val ) => {\n  return fullExtend(dest, Array.isArray(val) ? val : [val], true);\n}\n\n/**\n * @param  {Object} val, the parameter to check if it is a object\n * @return {Boolean} whether or not the parameter is an object\n */\nfunction isObject( val ) {\n  return val !== null && typeof val === 'object';\n}","import { defaultConfig } from './config';\nimport { setupScrollEvent, setupEvents } from './events'\nimport { deepExtend } from './utils';\n\n/**\n * Constructor for the library.\n * @param {Object} options, the configuration options for the lib.\n * @returns {Void}, nothing returned\n */\nfunction FixedHeader( options ) {\n\n  this.config = options ? deepExtend( defaultConfig, options ) : defaultConfig;\n  this.instance = {};\n  setupEvents.call( this );\n  setupScrollEvent.call( this );\n\n};\n\n\n// Options\n/*\n  type: Sticky, SlideReveal, FixedTop\n  options: {\n    fixedClass: String,\n    useStyles: true, // default\n    stickToElement: String or Element\n  }\n*/\n\n\nexport default FixedHeader;"],"names":[],"mappings":"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"}